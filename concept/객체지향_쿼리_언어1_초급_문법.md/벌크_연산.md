# 벌크 연산
> 벌크 연산이란 여러 개의 PK를 UPDATE, DELETE문을 사용하는 것이다.

## 벌크 연산 예시
- 어느 물류 센터 직원이 실수로 재고를 10개 주문했는데 상품의 옵션을 잘못 주문했다. 이 경우에 10개의 옵션을 변경해야 하지만 JPA 변경 감지 기능으로 업데이트를 실행하려면 너무 많은 SQL을 실행하게 된다.
    1. 재고의 개수를 리스트로 조회한다.
    2. 재고의 옵션을 모두 변경한다.
    3. 트랜잭션 커밋 시점에 변경감지가 동작한다.
- 변경된 데이터가 100건이라면 100번의 UPDATE SQL이 실행된다.

> JPA가 이런 벌크 쿼리보다 실시간으로 쿼리를 날리는 것을 선호하기 때문에 이런 케이스에선 벌크 연산을 하도록 개발해야 한다.

- 쿼리 한 번으로 여러 테이블 로우 변경(엔티티)
- executeUpdate()의 결과는 영향받은 엔티티 수 반환
- UPDATE, DELETE 지원
- INSERT 지원
```java
String qlString = "update Product p " +
 "set p.price = p.price * 1.1 " + 
 "where p.stockAmount < :stockAmount"; 
int resultCount = em.createQuery(qlString) 
 .setParameter("stockAmount", 10) 
 .executeUpdate();
 ```

 ## 벌크 연산 주의
 - 벌크 연산은 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리
    - 벌크 연산을 먼저 실행
    - __벌크 연산 수행 후 영속성 컨텍스트 초기화__
    - 왜냐하면, 벌크 연산 전에 조회했던 값이 1차 캐시에 남아있을 경우 벌크 연산을 통해 DB에 있는 값은 변해있는데 1차 캐시에 값은 그대로 남아있다면, 해당 값을 조회했을 때 DB에 있는 값을 조회하는 것이 아닌 1차캐시에 남아있는 값을 조회해오기 때문에 데이터 불일치가 발생한다.
    