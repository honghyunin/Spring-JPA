# JPA의 데이터 타입 분류

### 엔티티 타입
- `@Entity` 로 정의하는 객체
- 데이터가 변해도 식별자로 지속해서 추적 가능
- 예) 회원 엔티티의 키나 나이 값을 변경해도 식별자로 인식 가능

### 값 타입
- int, integer, String 처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체 식별자가 없고 값만 있으므로 변경 시 추적 불가
- 예) 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체

## 값 타입 분류
### 기본 값 타입
- 자바 기본 타입(int, double)
- 래퍼 클래스(integer, Long)
- String

- 생명주기를 엔티티에 의존
    - 예) 회원을 삭제하면 이름, 나이 필드도 함께 삭제
- 값 타입은 공유하면 X
    - 예) 회원 이름 변경 시 다른 회원의 이름도 함께 변경되면 안됨 (부정적인 의미의 사이드 이펙트)

> 자바의 기본 타입은 절대 공유 X
- int, double 같은 기본 타입(primitive type)은 절대 공유 X
- 기본 타입은 항상 값을 복사함
- Integer같은 래퍼 클래스나 String 같은 특수한 클래스는 공유 가능한 객체지만 변경 X

```java
int a = 10;
int b = a;

b = 20;
```
다음과 같은 상황에서 b에 a가 대입되고
다시 b에 20을 대입한다.

이 상황에서 b의 값은 너무 나 당연하게도 '20'이다.
하지만 여기서 중요한 관점은 `int b = a` 이 부분이다.

해당 부분에서 b가 a에 연결됐다고 생각할 수도 있지만, 그냥 b에 a의 __값__ 을 대입한 것이다.

하지만 wrapper class인 Integer 같은 것들은 값을 공유하게 된다.

```java
Integer a = new Integer(10);
Integer b = a;
```
위 코드에서 a의 값을 변경했을 때 b의 값은 무엇일까?

만약 a의 값을 `setA()` 와 같이 20으로 바꾼다면 b의 값도 a와 마찬가지로 __20이 된다__ 이유인 즉슨, `Integer b = a` 에서 b에게 a 값을 대입한 게 아니라 a의 reference(객체의 주소값)을 대입한 것이기 때문에 값을 서로 공유하게 된다.

### 임베디드 타입
- embedded type, 복합 값 타입 (좌표, 우편번호, 시간 같은 값 타입)
### 컬렉션 값 타입
- 컬렉션 값 타입(collection value type)